{
  "comments": [
    {
      "unresolved": false,
      "key": {
        "uuid": "a82d096f_a6f83c3f",
        "filename": "doc/source/developer/specs/tracing.rst",
        "patchSetId": 1
      },
      "lineNbr": 26,
      "author": {
        "id": 5263
      },
      "writtenOn": "2022-08-02T16:02:38Z",
      "side": 1,
      "message": "Nit: \"analysis\"",
      "revId": "30c046842459891d03654d6ceeaa46fa3f27bd57",
      "serverId": "4a232e18-c5a9-48ee-94c0-e04e7cca6543"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "bd4ef1c6_84224376",
        "filename": "doc/source/developer/specs/tracing.rst",
        "patchSetId": 1
      },
      "lineNbr": 53,
      "author": {
        "id": 9311
      },
      "writtenOn": "2022-08-02T13:28:19Z",
      "side": 1,
      "message": "Could the existing logging infrastructure be replaced by a console exporter? That is how the tracing library works in Rust, and it\u0027s quite useful because the same message are used for both console output and for opentelemetry service like jaeger.\n\nOtherwise, isn\u0027t this spec going to duplicate the existing work done on logging?",
      "revId": "30c046842459891d03654d6ceeaa46fa3f27bd57",
      "serverId": "4a232e18-c5a9-48ee-94c0-e04e7cca6543"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "0ff22820_9db506e9",
        "filename": "doc/source/developer/specs/tracing.rst",
        "patchSetId": 1
      },
      "lineNbr": 53,
      "author": {
        "id": 1
      },
      "writtenOn": "2022-08-02T14:59:58Z",
      "side": 1,
      "message": "This spec says that we will only use OpenTelemetry for emitting spans, not logs; we\u0027ll continue to use the existing python logging framework for that.  I definitely don\u0027t want to duplicate log infrastructure.\n\n(It\u0027s perfectly fine to only emit spans with Open Telemetry, and ignore the logs (and metrics) it supports.)",
      "parentUuid": "bd4ef1c6_84224376",
      "revId": "30c046842459891d03654d6ceeaa46fa3f27bd57",
      "serverId": "4a232e18-c5a9-48ee-94c0-e04e7cca6543"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "a2e819a6_0b1ee47a",
        "filename": "doc/source/developer/specs/tracing.rst",
        "patchSetId": 1
      },
      "lineNbr": 125,
      "author": {
        "id": 5263
      },
      "writtenOn": "2022-08-02T16:02:38Z",
      "side": 1,
      "message": "Nit: \"metadata\"",
      "revId": "30c046842459891d03654d6ceeaa46fa3f27bd57",
      "serverId": "4a232e18-c5a9-48ee-94c0-e04e7cca6543"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "203b029e_a64bbd63",
        "filename": "doc/source/developer/specs/tracing.rst",
        "patchSetId": 1
      },
      "lineNbr": 127,
      "author": {
        "id": 5263
      },
      "writtenOn": "2022-08-02T16:02:38Z",
      "side": 1,
      "message": "Nit: elswhere you capitalize as \"IDs\"",
      "revId": "30c046842459891d03654d6ceeaa46fa3f27bd57",
      "serverId": "4a232e18-c5a9-48ee-94c0-e04e7cca6543"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "f33e20ec_d697fb4c",
        "filename": "doc/source/developer/specs/tracing.rst",
        "patchSetId": 1
      },
      "lineNbr": 131,
      "author": {
        "id": 5263
      },
      "writtenOn": "2022-08-02T16:02:38Z",
      "side": 1,
      "message": "Was this meant to be underlined?",
      "revId": "30c046842459891d03654d6ceeaa46fa3f27bd57",
      "serverId": "4a232e18-c5a9-48ee-94c0-e04e7cca6543"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "80f60c04_d0d5dcd8",
        "filename": "doc/source/developer/specs/tracing.rst",
        "patchSetId": 1
      },
      "lineNbr": 146,
      "author": {
        "id": 5263
      },
      "writtenOn": "2022-08-02T16:02:38Z",
      "side": 1,
      "message": "And this?",
      "revId": "30c046842459891d03654d6ceeaa46fa3f27bd57",
      "serverId": "4a232e18-c5a9-48ee-94c0-e04e7cca6543"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "8724b949_923e11f0",
        "filename": "doc/source/developer/specs/tracing.rst",
        "patchSetId": 1
      },
      "lineNbr": 166,
      "author": {
        "id": 5263
      },
      "writtenOn": "2022-08-02T16:02:38Z",
      "side": 1,
      "message": "Is the plan for node requests to be represented here as well (at least the scheduler-side of issuing the request and then eventually receiving an assignment or not, and any reissuing)? At a minimum, being able to suss out which launcher(s) handled a request without needing to dig in the scheduler log would be nice, though if the traces also cover nodepool itself this could be even more useful.",
      "revId": "30c046842459891d03654d6ceeaa46fa3f27bd57",
      "serverId": "4a232e18-c5a9-48ee-94c0-e04e7cca6543"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "aa0249a1_4213bcf3",
        "filename": "doc/source/developer/specs/tracing.rst",
        "patchSetId": 1
      },
      "lineNbr": 193,
      "author": {
        "id": 27582
      },
      "writtenOn": "2022-07-26T14:03:42Z",
      "side": 1,
      "message": "Is this also true for the trace ID? Usually the trace ID is what connects all the spans and you can definitely propagate the trace context (which has the trace ID) and create a new span from that.\n\nI think a missing piece is that you can (de-)serialize a span, which we probably need.",
      "revId": "30c046842459891d03654d6ceeaa46fa3f27bd57",
      "serverId": "4a232e18-c5a9-48ee-94c0-e04e7cca6543"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "388389fb_3f3f7607",
        "filename": "doc/source/developer/specs/tracing.rst",
        "patchSetId": 1
      },
      "lineNbr": 193,
      "author": {
        "id": 1
      },
      "writtenOn": "2022-07-26T14:25:20Z",
      "side": 1,
      "message": "Given a root span for a trace, you can serialize/deserialize its trace context so that other systems can make child traces from it.  But the deserialization doesn\u0027t give you the root span, it gives you the trace context for the root span, which is only useful for creating child spans, not for emitting the root span itself.  The issue is that our root spans start on one host and end on another, and there isn\u0027t a way to serialize the span itself.  Here\u0027s what we want to do:\n\n1) Start root span on scheduler A\n2) Send trace context to merger\n3) Merger emits child span\n4) End root span on scheduler B and emit root span\n\nThat would work if we only had one scheduler, because the root span could be kept in memory.  But with multiple schedulers, and no way to serialize/deserialize the root span, we can\u0027t transfer the root span from step 1 to step 4.  So we need to augment the SDK somehow.\n\nWe could implement span serialization ourselves, but we don\u0027t actually need to do that, all we really need is the trace id, root span id, and timestamp of when the root span started.  I guess it is a form of serialization, but it\u0027s verify lightweight (we will only store that info, and not everything else like the list of errors, logs, events, etc).",
      "parentUuid": "aa0249a1_4213bcf3",
      "revId": "30c046842459891d03654d6ceeaa46fa3f27bd57",
      "serverId": "4a232e18-c5a9-48ee-94c0-e04e7cca6543"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "fba1cc24_d5b5cf4f",
        "filename": "doc/source/developer/specs/tracing.rst",
        "patchSetId": 1
      },
      "lineNbr": 201,
      "author": {
        "id": 27582
      },
      "writtenOn": "2022-07-26T14:07:59Z",
      "side": 1,
      "message": "Maybe something else worth exploring is how we want to configure this. When I wrote the initial prototype there was quite some config necessary depending on which exporter was used. But maybe that\u0027s a non-issue if we only support the OLTP exporter.",
      "revId": "30c046842459891d03654d6ceeaa46fa3f27bd57",
      "serverId": "4a232e18-c5a9-48ee-94c0-e04e7cca6543"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "862d45be_a63b89d4",
        "filename": "doc/source/developer/specs/tracing.rst",
        "patchSetId": 1
      },
      "lineNbr": 201,
      "author": {
        "id": 1
      },
      "writtenOn": "2022-07-26T14:25:20Z",
      "side": 1,
      "message": "Yeah, with only the OLTP exporter, it\u0027s a pretty small set of config options (just what you\u0027d expect: host, port, maybe protocol).  I don\u0027t see us needing more than an ini section with a few options.",
      "parentUuid": "fba1cc24_d5b5cf4f",
      "revId": "30c046842459891d03654d6ceeaa46fa3f27bd57",
      "serverId": "4a232e18-c5a9-48ee-94c0-e04e7cca6543"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "2d813751_932c8d0f",
        "filename": "doc/source/developer/specs/tracing.rst",
        "patchSetId": 1
      },
      "lineNbr": 280,
      "author": {
        "id": 5263
      },
      "writtenOn": "2022-08-02T16:02:38Z",
      "side": 1,
      "message": "Would this be segmented by tenant, in order to accommodate tenant-specific access controls and avoid leaking information about one to users who have access to another?",
      "revId": "30c046842459891d03654d6ceeaa46fa3f27bd57",
      "serverId": "4a232e18-c5a9-48ee-94c0-e04e7cca6543"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "39d8a092_7e0a44de",
        "filename": "doc/source/developer/specs/tracing.rst",
        "patchSetId": 1
      },
      "lineNbr": 314,
      "author": {
        "id": 9311
      },
      "writtenOn": "2022-08-02T13:28:19Z",
      "side": 1,
      "message": "It seems like opentelemetry-python metrics are compatible with prometheus client, and perhaps it would be preferable to migrate the existing gauge to use the same object for both use-case?",
      "revId": "30c046842459891d03654d6ceeaa46fa3f27bd57",
      "serverId": "4a232e18-c5a9-48ee-94c0-e04e7cca6543"
    }
  ]
}