{
  "comments": [
    {
      "unresolved": true,
      "key": {
        "uuid": "580adb07_0d71fe2a",
        "filename": "doc/source/developer/specs/nodepool-in-zuul.rst",
        "patchSetId": 1
      },
      "lineNbr": 231,
      "author": {
        "id": 4146
      },
      "writtenOn": "2024-06-24T20:14:47Z",
      "side": 1,
      "message": "Does switching to a uuid instead of a sequence imply we will have to scan all uuid\u0027s to determine which is oldest when it is time to delete the oldest image?\n\nI think this sort of change also implies some needed updates to status output as previously you can rely on sequence info to make sense of order but that will go away.",
      "range": {
        "startLine": 231,
        "startChar": 41,
        "endLine": 231,
        "endChar": 45
      },
      "revId": "e93bc2f53e7cf9276ab6e172b2e871881981f50a",
      "serverId": "4a232e18-c5a9-48ee-94c0-e04e7cca6543"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "5ebc39b9_4967570d",
        "filename": "doc/source/developer/specs/nodepool-in-zuul.rst",
        "patchSetId": 1
      },
      "lineNbr": 231,
      "author": {
        "id": 1
      },
      "writtenOn": "2024-06-24T21:04:01Z",
      "side": 1,
      "message": "We actually already sort-of implemented this in current nodepool.  This line is mostly just catching up to the reality.\n\nCurrent nodepool has an Age column in output for identifying newest/oldest image builds.",
      "parentUuid": "580adb07_0d71fe2a",
      "revId": "e93bc2f53e7cf9276ab6e172b2e871881981f50a",
      "serverId": "4a232e18-c5a9-48ee-94c0-e04e7cca6543"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "40cda478_e605cec2",
        "filename": "doc/source/developer/specs/nodepool-in-zuul.rst",
        "patchSetId": 1
      },
      "lineNbr": 231,
      "author": {
        "id": 4146
      },
      "writtenOn": "2024-06-24T21:16:07Z",
      "side": 1,
      "message": "Acknowledged",
      "parentUuid": "5ebc39b9_4967570d",
      "revId": "e93bc2f53e7cf9276ab6e172b2e871881981f50a",
      "serverId": "4a232e18-c5a9-48ee-94c0-e04e7cca6543"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "aafdeb55_b25b8b26",
        "filename": "doc/source/developer/specs/nodepool-in-zuul.rst",
        "patchSetId": 1
      },
      "lineNbr": 304,
      "author": {
        "id": 4146
      },
      "writtenOn": "2024-06-24T20:14:47Z",
      "side": 1,
      "message": "I\u0027m not sure I understand this new bullet. This has been the case for nodepool for many years. The only limitation was process per provider which is covered in the previous bullet.",
      "revId": "e93bc2f53e7cf9276ab6e172b2e871881981f50a",
      "serverId": "4a232e18-c5a9-48ee-94c0-e04e7cca6543"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "9b5def98_5729be6e",
        "filename": "doc/source/developer/specs/nodepool-in-zuul.rst",
        "patchSetId": 1
      },
      "lineNbr": 304,
      "author": {
        "id": 1
      },
      "writtenOn": "2024-06-24T21:04:01Z",
      "side": 1,
      "message": "Yes, but the unrevised spec has some locking such that effectively only a single launcher would be issuing cloud API calls for a given provider at a time (though any provider could do so, and they could rapidly switch to handle load).  The revision will allow multiple launchers to issue API calls to a single cloud at the same time.\n\nThis is particularly important for folks that only use a single cloud (or even a single region) as the performance of a single launcher determines their max throughput.  But even in opendev which achieves high throughput through parallelization across clouds, I expect us to be able to handle bursting better.",
      "parentUuid": "aafdeb55_b25b8b26",
      "revId": "e93bc2f53e7cf9276ab6e172b2e871881981f50a",
      "serverId": "4a232e18-c5a9-48ee-94c0-e04e7cca6543"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "70695f10_a7a83659",
        "filename": "doc/source/developer/specs/nodepool-in-zuul.rst",
        "patchSetId": 1
      },
      "lineNbr": 304,
      "author": {
        "id": 4146
      },
      "writtenOn": "2024-06-24T21:16:07Z",
      "side": 1,
      "message": "Acknowledged",
      "parentUuid": "9b5def98_5729be6e",
      "revId": "e93bc2f53e7cf9276ab6e172b2e871881981f50a",
      "serverId": "4a232e18-c5a9-48ee-94c0-e04e7cca6543"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "4134c53f_00f6d065",
        "filename": "doc/source/developer/specs/nodepool-in-zuul.rst",
        "patchSetId": 1
      },
      "lineNbr": 333,
      "author": {
        "id": 4146
      },
      "writtenOn": "2024-06-24T20:14:47Z",
      "side": 1,
      "message": "I think we should link to information on this hashing method as it appears to be complicated enough to warrant some more in depth info.\n\nMore specifically it appears that you can have a weighted variation of this algorithm, something that I think will be good to have here since different providers have built in weights (max-servers/capacity for nodes). But there are apparently different approaches with different drawbacks and understanding all of that is important.",
      "revId": "e93bc2f53e7cf9276ab6e172b2e871881981f50a",
      "serverId": "4a232e18-c5a9-48ee-94c0-e04e7cca6543"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "34b8bbc3_4ebc1b32",
        "filename": "doc/source/developer/specs/nodepool-in-zuul.rst",
        "patchSetId": 1
      },
      "lineNbr": 333,
      "author": {
        "id": 1
      },
      "writtenOn": "2024-06-24T21:04:01Z",
      "side": 1,
      "message": "I agree about the link.\n\nThe weights don\u0027t need to come into play here because the hash will be used for the following tasks:\n* Deciding which launcher will process a request (and assign nodes to it)\n* Deciding which launcher will drive the state machine for a node\n\nNeither of those involve provider capacity, it\u0027s merely deciding which launcher does some arbitrary piece of work.\n\nKeep in mind that with nodepool-in-zuul, this whole process is much more like how Zuul processes requests than nodepool does today.  There is normally no linkage* between a launcher and a cloud provider as there is today in nodepool, much in the same way that there is no zuul-scheduler assigned to the gate pipeline and another assigned to check.  Any zuul scheduler can start processing any pipeline at any time (it just needs to lock it first).  With nodepool-in-zuul, any launcher can start processing any request or any node at any time.  What this spec revision does is it allows the launcers to decide what requests and nodes to process before locking them.  It also allows them to process nodes from the same provider at the same time.\n\n* There may be a linkage between a launcher and a cloud provider, if a deployer decides that they need to locate a particular launcher in a particular cloud region due to network constraints.  But that doesn\u0027t change the fact that the decision about what cloud should launch what node is made independently, possibly by a different launcher.",
      "parentUuid": "4134c53f_00f6d065",
      "revId": "e93bc2f53e7cf9276ab6e172b2e871881981f50a",
      "serverId": "4a232e18-c5a9-48ee-94c0-e04e7cca6543"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "b1e40169_f2195f28",
        "filename": "doc/source/developer/specs/nodepool-in-zuul.rst",
        "patchSetId": 1
      },
      "lineNbr": 333,
      "author": {
        "id": 4146
      },
      "writtenOn": "2024-06-24T21:16:07Z",
      "side": 1,
      "message": "What is preventing a single cloud from handling all requests all the time then? The current system relies on zk request lock races which isn\u0027t ideal but does generally prevent a single provider from monopolizing things. This is important for keeping jobs away from relying on a single cloud provider by chance and then discovering that problem at some point in the future when you need all of your capacity.",
      "parentUuid": "34b8bbc3_4ebc1b32",
      "revId": "e93bc2f53e7cf9276ab6e172b2e871881981f50a",
      "serverId": "4a232e18-c5a9-48ee-94c0-e04e7cca6543"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "94b6406e_abc06682",
        "filename": "doc/source/developer/specs/nodepool-in-zuul.rst",
        "patchSetId": 1
      },
      "lineNbr": 333,
      "author": {
        "id": 1
      },
      "writtenOn": "2024-06-24T21:46:25Z",
      "side": 1,
      "message": "Good question!\n\nUp on lines 306-318 here on the new side (but in the original spec) it talks about assigning nodes to clouds more intentionally.  So basically, in the new world, some random launcher (with no affiliation with a cloud) will look at a request and say \"this request for 2 ubuntu nodes shall be handled by rax-dfw\" presumably because it saw that rax-dfw can handle ubuntu nodes, and also has sufficient capacity to launch them, or whatever other criteria we decide to use.  I imagine we will probably want to throw some randomization in there to avoid undesirable concentration.\n\nIn other words, the good news is that the process of cloud assignment of node requests is completely decoupled from any particular python process that\u0027s running.  The bad news is that this spec (either version) doesn\u0027t go into detail about how to implement all that.  But honestly, all we need to do is start with random.choice() to get going, then start improving from there.  This spec gives us the framework for that.",
      "parentUuid": "34b8bbc3_4ebc1b32",
      "revId": "e93bc2f53e7cf9276ab6e172b2e871881981f50a",
      "serverId": "4a232e18-c5a9-48ee-94c0-e04e7cca6543"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "1a278602_bd175c40",
        "filename": "doc/source/developer/specs/nodepool-in-zuul.rst",
        "patchSetId": 1
      },
      "lineNbr": 336,
      "author": {
        "id": 4146
      },
      "writtenOn": "2024-06-24T20:14:47Z",
      "side": 1,
      "message": "We would probably want to hash on request not node to simplify keeping multinode requests from consuming all the available locks. Basically ensure we\u0027re doing our best to process multiple requests in parallel rather than a single request in parallel.",
      "range": {
        "startLine": 336,
        "startChar": 59,
        "endLine": 336,
        "endChar": 74
      },
      "revId": "e93bc2f53e7cf9276ab6e172b2e871881981f50a",
      "serverId": "4a232e18-c5a9-48ee-94c0-e04e7cca6543"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "e9fcfb06_63f97cfc",
        "filename": "doc/source/developer/specs/nodepool-in-zuul.rst",
        "patchSetId": 1
      },
      "lineNbr": 336,
      "author": {
        "id": 1
      },
      "writtenOn": "2024-06-24T21:04:01Z",
      "side": 1,
      "message": "I think the \"or\" in that sentence was due to the fact that there are two queues we\u0027re hashing here:\n\n* There is a queue of nodeset requests; they will be hashed to decide which launcher should handle each.\n* There is a pile of nodes to be built; they will be hashed to decide which launcher will drive their state machines.\n\nI don\u0027t think multinode requests will have a particular advantage here.  The original request will be processed in order; then once there are multiple node records, the launchers should end up locking all of them.  If there are 5 launchers with 5 node requests, each will process 1.  If there are 5000 node requests, each should end up processing 1000.  That\u0027s fairly similar to the behavior today, except that once you exceed the capacity of the providers today, there\u0027s no more work for that nodepool-launcher to do, so you could end up with a nodepool-launcher handling 500 nodes and another handling 1500.  But a zuul-launcher will be able to evenly distribute them.",
      "parentUuid": "1a278602_bd175c40",
      "revId": "e93bc2f53e7cf9276ab6e172b2e871881981f50a",
      "serverId": "4a232e18-c5a9-48ee-94c0-e04e7cca6543"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "c27a66fb_22bcc097",
        "filename": "doc/source/developer/specs/nodepool-in-zuul.rst",
        "patchSetId": 1
      },
      "lineNbr": 336,
      "author": {
        "id": 4146
      },
      "writtenOn": "2024-06-24T21:16:07Z",
      "side": 1,
      "message": "I think my main concern here is that we can effectively serialize requests for each build depending on the number of launchers that are available. With the old setup as long as you ran more than one launcher you could start building nodes for multiple builds at once. The upside to this is that builds needing fewer resources can get started more quickly because they can bypass bottlenecks when larger nodesets are needed for other jobs.\n\nI like this behavior because it helps incentivize developers to avoid just always using all the resources all the time.",
      "parentUuid": "e9fcfb06_63f97cfc",
      "revId": "e93bc2f53e7cf9276ab6e172b2e871881981f50a",
      "serverId": "4a232e18-c5a9-48ee-94c0-e04e7cca6543"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "8a2cc2d2_bbcbfd5f",
        "filename": "doc/source/developer/specs/nodepool-in-zuul.rst",
        "patchSetId": 1
      },
      "lineNbr": 336,
      "author": {
        "id": 1
      },
      "writtenOn": "2024-06-24T21:46:25Z",
      "side": 1,
      "message": "We may be missing each other on this one still.\n\nI think the thing to keep in mind is that in all three cases, all nodes (up to the limit of quota) are being built simultaneously:\n* Today a single nodepool-launcher process can drive hundreds or thousands of node building state machines in parallel (from many different requests).\n* In the original spec, a zuul-launcher would do exactly the same thing, except that they would be decoupled from the zuul-launcher that originally converted the request into building nodes.\n* In the revised spec, the same is true, but the method of deciding which launcher would drive that state machine is math instead of a zk lock race.",
      "parentUuid": "e9fcfb06_63f97cfc",
      "revId": "e93bc2f53e7cf9276ab6e172b2e871881981f50a",
      "serverId": "4a232e18-c5a9-48ee-94c0-e04e7cca6543"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "5e5906ba_95234e89",
        "filename": "doc/source/developer/specs/nodepool-in-zuul.rst",
        "patchSetId": 1
      },
      "lineNbr": 367,
      "author": {
        "id": 4146
      },
      "writtenOn": "2024-06-24T20:14:47Z",
      "side": 1,
      "message": "Should we have a new state to represent the pre building needs a provider to actually build the node state? I think for human representation of things in status output that distinction is likely to be helpful.",
      "range": {
        "startLine": 367,
        "startChar": 4,
        "endLine": 367,
        "endChar": 14
      },
      "revId": "e93bc2f53e7cf9276ab6e172b2e871881981f50a",
      "serverId": "4a232e18-c5a9-48ee-94c0-e04e7cca6543"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "6a433d5a_94955758",
        "filename": "doc/source/developer/specs/nodepool-in-zuul.rst",
        "patchSetId": 1
      },
      "lineNbr": 370,
      "author": {
        "id": 4146
      },
      "writtenOn": "2024-06-24T20:14:47Z",
      "side": 1,
      "message": "Re the above comment flip the state to building once the lock is held and just before we start to drive the state machine in the next step below.",
      "revId": "e93bc2f53e7cf9276ab6e172b2e871881981f50a",
      "serverId": "4a232e18-c5a9-48ee-94c0-e04e7cca6543"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "ff03cdcd_43170634",
        "filename": "doc/source/developer/specs/nodepool-in-zuul.rst",
        "patchSetId": 1
      },
      "lineNbr": 426,
      "author": {
        "id": 4146
      },
      "writtenOn": "2024-06-24T20:14:47Z",
      "side": 1,
      "message": "In the case of OpenStack clouds I don\u0027t think there is a consistent standard for these sorts of errors/rate limits. I don\u0027t think openstack proper implements rate limits in its APIs so these errors come from proxies in front of the API services. The problem set is probably small enough to not be a huge problem, but may lead to a bunch of special casing over time.",
      "revId": "e93bc2f53e7cf9276ab6e172b2e871881981f50a",
      "serverId": "4a232e18-c5a9-48ee-94c0-e04e7cca6543"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "c9f248f5_ff3cec94",
        "filename": "doc/source/developer/specs/nodepool-in-zuul.rst",
        "patchSetId": 1
      },
      "lineNbr": 426,
      "author": {
        "id": 1
      },
      "writtenOn": "2024-06-24T21:04:01Z",
      "side": 1,
      "message": "Good point.  So we may need to design this to handle several different sources/manifestations of errors (whether it comes from headers or 4xx response text, etc).",
      "parentUuid": "ff03cdcd_43170634",
      "revId": "e93bc2f53e7cf9276ab6e172b2e871881981f50a",
      "serverId": "4a232e18-c5a9-48ee-94c0-e04e7cca6543"
    }
  ]
}