{
  "comments": [
    {
      "unresolved": true,
      "key": {
        "uuid": "1c1eb07e_a5bf7314",
        "filename": "doc/source/developer/model-changelog.rst",
        "patchSetId": 5
      },
      "lineNbr": 95,
      "author": {
        "id": 4146
      },
      "writtenOn": "2022-09-09T21:58:23Z",
      "side": 1,
      "message": "Nit, typo should be \"nodeset\".",
      "range": {
        "startLine": 95,
        "startChar": 22,
        "endLine": 95,
        "endChar": 28
      },
      "revId": "1958bbad03d4c2eb59502df8682bdfcb248400c2",
      "serverId": "4a232e18-c5a9-48ee-94c0-e04e7cca6543"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "26434fe6_d669bb88",
        "filename": "tests/unit/test_model_upgrade.py",
        "patchSetId": 5
      },
      "lineNbr": 245,
      "author": {
        "id": 4146
      },
      "writtenOn": "2022-09-09T21:58:23Z",
      "side": 1,
      "message": "In this case we enqueue with the first scheduler under model api 8. Then we have the second scheduler use model api 9 to execute the job? Since we use nodepool to control when things are processed do we need two separate schedulers? I guess this ensures that we\u0027re using the new model api to process things?",
      "revId": "1958bbad03d4c2eb59502df8682bdfcb248400c2",
      "serverId": "4a232e18-c5a9-48ee-94c0-e04e7cca6543"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "958a1391_8f4a30d8",
        "filename": "tests/unit/test_model_upgrade.py",
        "patchSetId": 5
      },
      "lineNbr": 245,
      "author": {
        "id": 1
      },
      "writtenOn": "2022-09-09T22:51:27Z",
      "side": 1,
      "message": "It tests that a scheduler can load the old data with nothing cached.",
      "parentUuid": "26434fe6_d669bb88",
      "revId": "1958bbad03d4c2eb59502df8682bdfcb248400c2",
      "serverId": "4a232e18-c5a9-48ee-94c0-e04e7cca6543"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "2bdd7680_64614f93",
        "filename": "tests/unit/test_model_upgrade.py",
        "patchSetId": 5
      },
      "lineNbr": 245,
      "author": {
        "id": 4146
      },
      "writtenOn": "2022-09-09T23:21:01Z",
      "side": 1,
      "message": "Ack",
      "parentUuid": "958a1391_8f4a30d8",
      "revId": "1958bbad03d4c2eb59502df8682bdfcb248400c2",
      "serverId": "4a232e18-c5a9-48ee-94c0-e04e7cca6543"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "62475ba4_7ea4edb8",
        "filename": "zuul/model.py",
        "patchSetId": 5
      },
      "lineNbr": 1467,
      "author": {
        "id": 4146
      },
      "writtenOn": "2022-09-09T21:58:23Z",
      "side": 1,
      "message": "Would it make sense to make _flattenAlternatives a static class method to make the argument for recursion a little less odd? Minor nit.",
      "range": {
        "startLine": 1467,
        "startChar": 42,
        "endLine": 1467,
        "endChar": 46
      },
      "revId": "1958bbad03d4c2eb59502df8682bdfcb248400c2",
      "serverId": "4a232e18-c5a9-48ee-94c0-e04e7cca6543"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "4707ecf1_91306b28",
        "filename": "zuul/model.py",
        "patchSetId": 5
      },
      "lineNbr": 1467,
      "author": {
        "id": 1
      },
      "writtenOn": "2022-09-09T22:51:27Z",
      "side": 1,
      "message": "I don\u0027t really see a difference either way.",
      "parentUuid": "62475ba4_7ea4edb8",
      "range": {
        "startLine": 1467,
        "startChar": 42,
        "endLine": 1467,
        "endChar": 46
      },
      "revId": "1958bbad03d4c2eb59502df8682bdfcb248400c2",
      "serverId": "4a232e18-c5a9-48ee-94c0-e04e7cca6543"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "facf1425_43c04179",
        "filename": "zuul/model.py",
        "patchSetId": 5
      },
      "lineNbr": 1467,
      "author": {
        "id": 4146
      },
      "writtenOn": "2022-09-09T23:21:01Z",
      "side": 1,
      "message": "Ack",
      "parentUuid": "4707ecf1_91306b28",
      "range": {
        "startLine": 1467,
        "startChar": 42,
        "endLine": 1467,
        "endChar": 46
      },
      "revId": "1958bbad03d4c2eb59502df8682bdfcb248400c2",
      "serverId": "4a232e18-c5a9-48ee-94c0-e04e7cca6543"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "4388e1ac_36bfda7c",
        "filename": "zuul/model.py",
        "patchSetId": 5
      },
      "lineNbr": 1489,
      "author": {
        "id": 4146
      },
      "writtenOn": "2022-09-09T21:58:23Z",
      "side": 1,
      "message": "Do we need an extra method for this?",
      "revId": "1958bbad03d4c2eb59502df8682bdfcb248400c2",
      "serverId": "4a232e18-c5a9-48ee-94c0-e04e7cca6543"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "c0abe0f1_d42da665",
        "filename": "zuul/model.py",
        "patchSetId": 5
      },
      "lineNbr": 1489,
      "author": {
        "id": 1
      },
      "writtenOn": "2022-09-09T22:51:27Z",
      "side": 1,
      "message": "It\u0027s an API.  Several model objects have this method.  It\u0027s used in configloader.  It may do other things in the future.",
      "parentUuid": "4388e1ac_36bfda7c",
      "revId": "1958bbad03d4c2eb59502df8682bdfcb248400c2",
      "serverId": "4a232e18-c5a9-48ee-94c0-e04e7cca6543"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "97618216_673dd677",
        "filename": "zuul/model.py",
        "patchSetId": 5
      },
      "lineNbr": 1489,
      "author": {
        "id": 4146
      },
      "writtenOn": "2022-09-09T23:21:01Z",
      "side": 1,
      "message": "It mostly just reads oddly to pass in self when self is already implicitly passed. But it makes sense when you read the method and find that it is recursive.",
      "parentUuid": "c0abe0f1_d42da665",
      "revId": "1958bbad03d4c2eb59502df8682bdfcb248400c2",
      "serverId": "4a232e18-c5a9-48ee-94c0-e04e7cca6543"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "7bb875e7_9f473e1d",
        "filename": "zuul/model.py",
        "patchSetId": 5
      },
      "lineNbr": 2247,
      "author": {
        "id": 4146
      },
      "writtenOn": "2022-09-09T21:58:23Z",
      "side": 1,
      "message": "Since we write both the nodeset_alternatives and nodeset in the serialize case that means we can override the singleton nodeset definition above if not all components are at api version 9.\n\nThis isn\u0027t a major issue, but it does point out a behavior expectation question. Should we continue to act as v8 until everything is v9 or are we ok to act like v9 here? I\u0027m concerend that reasoning through all the corner cases for v8 mixed with v9 here may be difficult and we\u0027re better off just proceeding with v8 instead for consistency with all nodes.\n\nAll that to say maybe this block from 2246-2247 needs to be in an else case for the block at 2240-2244? Then do the data conversion in 2248-2250 if necessary.",
      "revId": "1958bbad03d4c2eb59502df8682bdfcb248400c2",
      "serverId": "4a232e18-c5a9-48ee-94c0-e04e7cca6543"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "3a04d7a1_f9c69f06",
        "filename": "zuul/model.py",
        "patchSetId": 5
      },
      "lineNbr": 2247,
      "author": {
        "id": 1
      },
      "writtenOn": "2022-09-09T22:51:27Z",
      "side": 1,
      "message": "The current code does mean that once sufficient numbers of nodes are API-9-capable, they will immediately start obeying the alternatives even before all components are updated.  But any \u003c9 components will still work as before.\n\nGiven that we\u0027re talking about a pretty long process with frozen jobs, etc, it doesn\u0027t seem *wrong*, per se, to start obeying alternatives for jobs that have already been frozen if they were configured that way.\n\nBut I think the thing that makes this more-or-less moot is that it seems *very* unlikely for the system to already have nodeset alternatives configured during the upgrade process since it\u0027s a new config syntax.  So this shouldn\u0027t really matter in practice.",
      "parentUuid": "7bb875e7_9f473e1d",
      "revId": "1958bbad03d4c2eb59502df8682bdfcb248400c2",
      "serverId": "4a232e18-c5a9-48ee-94c0-e04e7cca6543"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "d2352568_befce39c",
        "filename": "zuul/model.py",
        "patchSetId": 5
      },
      "lineNbr": 2247,
      "author": {
        "id": 4146
      },
      "writtenOn": "2022-09-09T23:21:01Z",
      "side": 1,
      "message": "That is a good point. I agree it is unlikely for people to immediately start using the feature before we\u0027ve transitioned completely to the new api in a cluster.",
      "parentUuid": "3a04d7a1_f9c69f06",
      "revId": "1958bbad03d4c2eb59502df8682bdfcb248400c2",
      "serverId": "4a232e18-c5a9-48ee-94c0-e04e7cca6543"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "1a9b024d_2ae4ab34",
        "filename": "zuul/model.py",
        "patchSetId": 5
      },
      "lineNbr": 2528,
      "author": {
        "id": 4146
      },
      "writtenOn": "2022-09-09T21:58:23Z",
      "side": 1,
      "message": "I\u0027m not sure I understand the len(alts[0]) check here. We perform the same action in this block as the elif below. Can they be combined?\n\nIn particular if alts[0] is a str or a dict len(alts[0]) will report non zero value for non empty vars. And if it is a NodeSet object then len() won\u0027t apply to it?",
      "revId": "1958bbad03d4c2eb59502df8682bdfcb248400c2",
      "serverId": "4a232e18-c5a9-48ee-94c0-e04e7cca6543"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "8b7be77a_cd438c82",
        "filename": "zuul/model.py",
        "patchSetId": 5
      },
      "lineNbr": 2528,
      "author": {
        "id": 1
      },
      "writtenOn": "2022-09-09T22:51:27Z",
      "side": 1,
      "message": "Re the first thing: the two blocks assign to different dictionary keys (nodeset vs nodeset_alternatives), so the actions aren\u0027t quite the same (not sure if that\u0027s what you meant or not).\n\nRe the second: flattenNodesetAlternatives will always return a list of Nodeset objects, so alts[0] if it exists is always a nodeset.  Nodeset implements __len__ which indicates how many nodes it has.  So these lines say:\n\nIf there is only one nodeset and it has nodes, set the \u0027nodeset\u0027 attribute to that nodeset.\nIf there is more than one nodeset, set the \u0027nodeset_alternatives\u0027 attribute to the list.\nIf there are no nodesets or the single nodeset is the empty nodeset, set no attributes.\n\nThis retains the old behavior where the nodeset attribute is not included on jobs that don\u0027t specify it.",
      "parentUuid": "1a9b024d_2ae4ab34",
      "revId": "1958bbad03d4c2eb59502df8682bdfcb248400c2",
      "serverId": "4a232e18-c5a9-48ee-94c0-e04e7cca6543"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "c8df41f4_b35a72c0",
        "filename": "zuul/model.py",
        "patchSetId": 5
      },
      "lineNbr": 2528,
      "author": {
        "id": 4146
      },
      "writtenOn": "2022-09-09T23:21:01Z",
      "side": 1,
      "message": "Thanks, I think the bit I was missing is that nodeset may not be set if it is empty. Reading the old code it seems that it wasn\u0027t set if there was no nodeset in the layout. Which is maybe equivalent here.\n\nThat said, now I\u0027m wondering why we allow FrozenJob and Job to differ when it comes to having a nodeset or nodeset_alteratives attribute. Should we try and use nodeset_alternatives everywhere for consistency? Do we not do that because the name in the yaml is still nodeset ? And if so is it safe to sometimes have a nodeset_alternatives here instead? We don\u0027t set a nodeset_alternatives below at line 2570.",
      "parentUuid": "8b7be77a_cd438c82",
      "revId": "1958bbad03d4c2eb59502df8682bdfcb248400c2",
      "serverId": "4a232e18-c5a9-48ee-94c0-e04e7cca6543"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "3ba5e297_07545e93",
        "filename": "zuul/model.py",
        "patchSetId": 5
      },
      "lineNbr": 2528,
      "author": {
        "id": 1
      },
      "writtenOn": "2022-09-09T23:45:23Z",
      "side": 1,
      "message": "A job (now, just as before) has a single nodeset.  That nodeset used to be a single, um, set of nodes.  But now it is actually an even more complex data structure which may be a set of nodes, or it may be a tree of sets of nodes.  Regardless, when we\u0027re talking about a Job representing what the user specified in the config, it merely has a nodeset.\n\nGiven that, we could just stop there and never have anything called \"nodeset_alternatives\" on the Job.\n\nHowever, when we think about what users want to see in the web UI, when you\u0027re looking at a Job in the web UI, you\u0027re looking at a visual representation of the definition.  To date, if a user specified a nodeset by name on a job, we would look up the nodeset and show the actual definition of the nodeset.  But now that nodesets are complex tree data structures, if we were to do that we would have quite a challenge to display it on the job page.  It\u0027s possible, but I don\u0027t relish the idea, and I don\u0027t think it\u0027s necessary.  I think the most useful thing for the user would be to go ahead and flatten the nodeset alternatives into a list and display them as a sequence.  Basically \"this job is defined such that it will use these nodesets in sequence\".  To accomodate this use case, we flatten the nodeset in Job.toDict.\n\nA FrozenJob is geared specifically for executing it, so we flatten everything so that we can just run through the list of possible nodesets.  It has no need of a nodeset attribute (except that we use it as a pointer to \"the current nodeset within the nodeset alternatives\").",
      "parentUuid": "c8df41f4_b35a72c0",
      "revId": "1958bbad03d4c2eb59502df8682bdfcb248400c2",
      "serverId": "4a232e18-c5a9-48ee-94c0-e04e7cca6543"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "a5bff6d6_2165f41a",
        "filename": "zuul/model.py",
        "patchSetId": 5
      },
      "lineNbr": 2528,
      "author": {
        "id": 4146
      },
      "writtenOn": "2022-09-09T23:54:36Z",
      "side": 1,
      "message": "Got it, so this is purely to support human visible representation. I was worried there was some mismatch in attributes that would create functional problems. But I can see where we freeze the job we don\u0027t use the toDict representation we build a new direct representation for the frozen state. So toDict here must be going straight out to API responses.",
      "parentUuid": "3ba5e297_07545e93",
      "revId": "1958bbad03d4c2eb59502df8682bdfcb248400c2",
      "serverId": "4a232e18-c5a9-48ee-94c0-e04e7cca6543"
    }
  ]
}