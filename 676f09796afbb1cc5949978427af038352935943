{
  "comments": [
    {
      "key": {
        "uuid": "bf659307_14bd3ad7",
        "filename": "doc/source/developer/specs/container-build-resources.rst",
        "patchSetId": 1
      },
      "lineNbr": 84,
      "author": {
        "id": 9311
      },
      "writtenOn": "2018-04-11T14:49:31Z",
      "side": 1,
      "message": "Perhaps we should list the tasks to look for when running with the kubectl or raw ansible module? For example synchronize or zuul_stream may work differently.\n\nOr are we expecting a new set of zuul-jobs when using container build resources?",
      "revId": "676f09796afbb1cc5949978427af038352935943",
      "serverId": "4a232e18-c5a9-48ee-94c0-e04e7cca6543",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "bf659307_15ba116d",
        "filename": "doc/source/developer/specs/container-build-resources.rst",
        "patchSetId": 1
      },
      "lineNbr": 84,
      "author": {
        "id": 4146
      },
      "writtenOn": "2018-04-11T18:29:08Z",
      "side": 1,
      "message": "Out of curiosity if the intent is to run VM compute like containers why not make the command to run sshd and just ssh in like other VM/baremetal compute instances?\n\nThen synchronize and just about everything else should continue to work as is right?\n\nI think it may be simplest to just have the general compute base job that expects eg ssh and then that works regardless of being a container, vm, or baremetal.\n\nAdditionally doing it this way would more easily open the door to people using lxc instead of k8s and so on. Since the base interaction remains the same and you\u0027d just need to update nodepool to speak to the provisioner.",
      "parentUuid": "bf659307_14bd3ad7",
      "revId": "676f09796afbb1cc5949978427af038352935943",
      "serverId": "4a232e18-c5a9-48ee-94c0-e04e7cca6543",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "bf659307_78281d85",
        "filename": "doc/source/developer/specs/container-build-resources.rst",
        "patchSetId": 1
      },
      "lineNbr": 84,
      "author": {
        "id": 1
      },
      "writtenOn": "2018-04-11T23:29:15Z",
      "side": 1,
      "message": "Tristan, indeed -- synchronize may or may not work (I\u0027m not sure about that).  I don\u0027t have an answer for zuul_stream, but I bet we could, if we wanted, plumb the container stdout to the log streaming system.  Aside from those things (which are handled in base jobs, and therefore, we can solve them once for the whole system), I think that most simple jobs should \"just work\".  That is, once you\u0027ve got the git repos copied over, whether \"tox\" is executed by kubectl or ssh the results should be the same.\n\nWe should definitely update this to include this info.\n\nClark, ssh-ing into a container is certainly a thing one might want to do, however, it requires setting up a service and ingress access to the cluster, which is not always guaranteed to be present.  Being able to support the non-ssh case means we can work in more environments (and possibly with smaller images).\n\nBut maybe we should support the ssh-case better as well?",
      "revId": "676f09796afbb1cc5949978427af038352935943",
      "serverId": "4a232e18-c5a9-48ee-94c0-e04e7cca6543",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "bf659307_0ed99854",
        "filename": "doc/source/developer/specs/container-build-resources.rst",
        "patchSetId": 1
      },
      "lineNbr": 84,
      "author": {
        "id": 9311
      },
      "writtenOn": "2018-04-12T04:25:12Z",
      "side": 1,
      "message": "James, there is also the custom task such as tox_install_sibling_packages which may not work too. Also note that according to the synchronize module source, it currently only works via ssh, docker client or a direct filesystem. This would be a big drawback as upload-logs and fetch-* roles relies on it.\n\nI agree with Clark, containers behaving like a machine should run sshd.",
      "parentUuid": "bf659307_78281d85",
      "revId": "676f09796afbb1cc5949978427af038352935943",
      "serverId": "4a232e18-c5a9-48ee-94c0-e04e7cca6543",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "bf659307_333cf12d",
        "filename": "doc/source/developer/specs/container-build-resources.rst",
        "patchSetId": 1
      },
      "lineNbr": 84,
      "author": {
        "id": 1
      },
      "writtenOn": "2018-04-12T15:55:31Z",
      "side": 1,
      "message": "Upload-logs doesn\u0027t interact with the worker, so that\u0027s not relevant here.\n\nWhy would tox_install_sibling_packages not work?\n\nThe fetch roles do rely on synchronize.  We may be able to get synchronize to work with kubectl (if it works with docker, it may be able to work with kubectl).\n\nWe can *certainly* run a container with sshd, but I think this is much more compelling if we design for being able to execute simple container workloads without it.  Requiring ssh and ingress support is a big thing to ask and puts us at a disadvantage.\n\nOf course if it better fits the specific workload, a user *can* run sshd.  So to be clear about what we want, how about I update this to explicitly discuss the non-sshd use case, but also the sshd use-case, and what\u0027s needed to support both?",
      "revId": "676f09796afbb1cc5949978427af038352935943",
      "serverId": "4a232e18-c5a9-48ee-94c0-e04e7cca6543",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "bf659307_6e6709b9",
        "filename": "doc/source/developer/specs/container-build-resources.rst",
        "patchSetId": 1
      },
      "lineNbr": 134,
      "author": {
        "id": 3099
      },
      "writtenOn": "2018-04-11T13:27:06Z",
      "side": 1,
      "message": "Will be interesting to consider any OpenShift limits here (which I\u0027m unfamiliar with). E.g., the link below discusses limits on the number of projects that can be created. \"admin\" level users do not have a limit, but not sure of the implications of Nodepool using an account at that level.\n\nhttps://docs.openshift.com/container-platform/3.3/admin_guide/managing_projects.html#limit-projects-per-user",
      "range": {
        "startLine": 133,
        "startChar": 0,
        "endLine": 134,
        "endChar": 70
      },
      "revId": "676f09796afbb1cc5949978427af038352935943",
      "serverId": "4a232e18-c5a9-48ee-94c0-e04e7cca6543",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "bf659307_982df196",
        "filename": "doc/source/developer/specs/container-build-resources.rst",
        "patchSetId": 1
      },
      "lineNbr": 134,
      "author": {
        "id": 1
      },
      "writtenOn": "2018-04-11T23:29:15Z",
      "side": 1,
      "message": "That looks to be an administrative choice.  But yeah, I guess we have \"quota\". :)",
      "revId": "676f09796afbb1cc5949978427af038352935943",
      "serverId": "4a232e18-c5a9-48ee-94c0-e04e7cca6543",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "bf659307_2e0b51d6",
        "filename": "doc/source/developer/specs/container-build-resources.rst",
        "patchSetId": 1
      },
      "lineNbr": 137,
      "author": {
        "id": 3099
      },
      "writtenOn": "2018-04-11T13:27:06Z",
      "side": 1,
      "message": "nit: s/accouns/accounts/",
      "range": {
        "startLine": 137,
        "startChar": 48,
        "endLine": 137,
        "endChar": 55
      },
      "revId": "676f09796afbb1cc5949978427af038352935943",
      "serverId": "4a232e18-c5a9-48ee-94c0-e04e7cca6543",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "bf659307_34be3eb4",
        "filename": "doc/source/developer/specs/container-build-resources.rst",
        "patchSetId": 1
      },
      "lineNbr": 153,
      "author": {
        "id": 9311
      },
      "writtenOn": "2018-04-11T14:49:31Z",
      "side": 1,
      "message": "Perhaps this could be solved using the OpenShift s2i tool: https://docs.openshift.com/enterprise/3.0/creating_images/s2i.html",
      "revId": "676f09796afbb1cc5949978427af038352935943",
      "serverId": "4a232e18-c5a9-48ee-94c0-e04e7cca6543",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "bf659307_381e255f",
        "filename": "doc/source/developer/specs/container-build-resources.rst",
        "patchSetId": 1
      },
      "lineNbr": 153,
      "author": {
        "id": 1
      },
      "writtenOn": "2018-04-11T23:29:15Z",
      "side": 1,
      "message": "IIUC, that\u0027s basically the \"run a process in a container to build an image\" model, so it might fit into the \u0027container native workflow\u0027 process.  The question is: how to get the speculative source code into that image.  It looks like s2i does that by \"downloading the source\" inside the container.  But Zuul v3 is a push system; there\u0027s no place to download the source from.  That\u0027s why this section describes pushing git repos into a container.\n\nBut if we push our git repo state onto a sidecar container attached to a pod running s2i with a shared volume, the s2i script could just be \"copy over the git repos from the shared volume\".  I don\u0027t know much about s2i though, so there\u0027s probably more to explore here.",
      "revId": "676f09796afbb1cc5949978427af038352935943",
      "serverId": "4a232e18-c5a9-48ee-94c0-e04e7cca6543",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "bf659307_ee7a2422",
        "filename": "doc/source/developer/specs/container-build-resources.rst",
        "patchSetId": 1
      },
      "lineNbr": 153,
      "author": {
        "id": 9311
      },
      "writtenOn": "2018-04-12T04:25:12Z",
      "side": 1,
      "message": "Couldn\u0027t we just make the s2i process fetch from the zuul-merger/executor? Container shouldn\u0027t have the tool to build and install the source, iiuc the image needs to be built before being started and tested.",
      "parentUuid": "bf659307_381e255f",
      "revId": "676f09796afbb1cc5949978427af038352935943",
      "serverId": "4a232e18-c5a9-48ee-94c0-e04e7cca6543",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "bf659307_d34495ba",
        "filename": "doc/source/developer/specs/container-build-resources.rst",
        "patchSetId": 1
      },
      "lineNbr": 153,
      "author": {
        "id": 1
      },
      "writtenOn": "2018-04-12T15:55:31Z",
      "side": 1,
      "message": "The executor is not remotely accessible.",
      "revId": "676f09796afbb1cc5949978427af038352935943",
      "serverId": "4a232e18-c5a9-48ee-94c0-e04e7cca6543",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "bf659307_95014109",
        "filename": "doc/source/developer/specs/container-build-resources.rst",
        "patchSetId": 1
      },
      "lineNbr": 163,
      "author": {
        "id": 4146
      },
      "writtenOn": "2018-04-11T18:29:08Z",
      "side": 1,
      "message": "I think some of this cumbersomeness may be beneficial if it doesn\u0027t tie you to a specific container tool like k8s and since you\u0027d have to run a long lived process in k8s anyways having that be sshd doesn\u0027t seem like too much effort?\n\nI think my biggest concern with this is we are calling it the  containers that behave like a machine but then tying it explicitly to k8s which does the opposite of behaving like a machine. I would expect users to that want containers to behave like a machine to be looking at alternatives like lxc/lxd since that is what they do (act like machines).\n\nMaybe we \"optimize\" k8s for this use case if k8s is chosen but not necessarily build the system around that expectation?",
      "revId": "676f09796afbb1cc5949978427af038352935943",
      "serverId": "4a232e18-c5a9-48ee-94c0-e04e7cca6543",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "bf659307_5823d9a7",
        "filename": "doc/source/developer/specs/container-build-resources.rst",
        "patchSetId": 1
      },
      "lineNbr": 163,
      "author": {
        "id": 1
      },
      "writtenOn": "2018-04-11T23:29:15Z",
      "side": 1,
      "message": "The ssh aspect is addressed above.  This process is in its own section because it has relevance to both \u0027containers like a machine\u0027 and \u0027container native workflow\u0027.  It\u0027s really hard for me to see how to build a container image based on a git repo in a container without this, and that\u0027s step 0 for container native.\n\nI do think this can apply to any container system where you can run a command in a container with stdin/stdout connected.",
      "revId": "676f09796afbb1cc5949978427af038352935943",
      "serverId": "4a232e18-c5a9-48ee-94c0-e04e7cca6543",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "bf659307_4e1470a0",
        "filename": "doc/source/developer/specs/container-build-resources.rst",
        "patchSetId": 1
      },
      "lineNbr": 163,
      "author": {
        "id": 9311
      },
      "writtenOn": "2018-04-12T04:25:12Z",
      "side": 1,
      "message": "That sounds like a special use-case where the image is built inside a container. Projects may build the software on a regular system and only install the final package into an image.",
      "parentUuid": "bf659307_5823d9a7",
      "revId": "676f09796afbb1cc5949978427af038352935943",
      "serverId": "4a232e18-c5a9-48ee-94c0-e04e7cca6543",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "bf659307_30d40320",
        "filename": "doc/source/developer/specs/container-build-resources.rst",
        "patchSetId": 1
      },
      "lineNbr": 223,
      "author": {
        "id": 4146
      },
      "writtenOn": "2018-04-11T18:29:08Z",
      "side": 1,
      "message": "Based on our current set of container tester users I expect that this particular use case will be very popular. And that for most users this is what they will want at least for their \"base\" testing.\n\n++ to supporting this use case.",
      "revId": "676f09796afbb1cc5949978427af038352935943",
      "serverId": "4a232e18-c5a9-48ee-94c0-e04e7cca6543",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "bf659307_90eaafd5",
        "filename": "doc/source/developer/specs/container-build-resources.rst",
        "patchSetId": 1
      },
      "lineNbr": 227,
      "author": {
        "id": 4146
      },
      "writtenOn": "2018-04-11T18:29:08Z",
      "side": 1,
      "message": "Worth considering that using the build job then N test jobs model isn\u0027t limited to having a single build job with N test jobs.\n\nWe could set it up such that for each partition there was a separate build job X with N_x test jobs following it to handle the general case.\n\nThen you end up having the same mechanism regardless of need.",
      "revId": "676f09796afbb1cc5949978427af038352935943",
      "serverId": "4a232e18-c5a9-48ee-94c0-e04e7cca6543",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "bf659307_f83bcdcd",
        "filename": "doc/source/developer/specs/container-build-resources.rst",
        "patchSetId": 1
      },
      "lineNbr": 227,
      "author": {
        "id": 1
      },
      "writtenOn": "2018-04-11T23:29:15Z",
      "side": 1,
      "message": "Yeah, IIUC, the suggestion on line 231 can be generalized as: each root node in a buildset\u0027s job graph gets its own registry.",
      "revId": "676f09796afbb1cc5949978427af038352935943",
      "serverId": "4a232e18-c5a9-48ee-94c0-e04e7cca6543",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "bf659307_5090974a",
        "filename": "doc/source/developer/specs/container-build-resources.rst",
        "patchSetId": 1
      },
      "lineNbr": 241,
      "author": {
        "id": 4146
      },
      "writtenOn": "2018-04-11T18:29:08Z",
      "side": 1,
      "message": "Similarly to my concerns about assuming k8s for the container like machine case, I think it may be beneficial to not assume openshift for the container orchestration case. For this particular case assuming k8s is probably fine since it appears to be the thing everyone is using, but not sure we should assume additional openshift features.",
      "revId": "676f09796afbb1cc5949978427af038352935943",
      "serverId": "4a232e18-c5a9-48ee-94c0-e04e7cca6543",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "bf659307_8ea7e850",
        "filename": "doc/source/developer/specs/container-build-resources.rst",
        "patchSetId": 1
      },
      "lineNbr": 241,
      "author": {
        "id": 9311
      },
      "writtenOn": "2018-04-12T04:25:12Z",
      "side": 1,
      "message": "I agree with Clark, moreover OpenShift projects may already be using the included ci/cd pipelines. Shouldn\u0027t the spec be splitted in two, one section for image building (e.g. covering docker file or buildah script), and one section for image runtime covering different providers like runc, docker or k8s?",
      "parentUuid": "bf659307_5090974a",
      "revId": "676f09796afbb1cc5949978427af038352935943",
      "serverId": "4a232e18-c5a9-48ee-94c0-e04e7cca6543",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "bf659307_100a0d78",
        "filename": "doc/source/developer/specs/container-build-resources.rst",
        "patchSetId": 1
      },
      "lineNbr": 241,
      "author": {
        "id": 7069
      },
      "writtenOn": "2018-04-12T09:19:44Z",
      "side": 1,
      "message": "I think clarifying the building (and where it is built) vs the running vs the interacting/subsequent testing would be helpful (either in this spec or supplementary specs)",
      "parentUuid": "bf659307_8ea7e850",
      "revId": "676f09796afbb1cc5949978427af038352935943",
      "serverId": "4a232e18-c5a9-48ee-94c0-e04e7cca6543",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "bf659307_f40f6685",
        "filename": "doc/source/developer/specs/container-build-resources.rst",
        "patchSetId": 1
      },
      "lineNbr": 242,
      "author": {
        "id": 9311
      },
      "writtenOn": "2018-04-11T14:49:31Z",
      "side": 1,
      "message": "IIRC there was discussion about an intermediate job state (e.g. \"CONTINUE\") that a parent job could use to indicate the scheduler that child job can start while keeping the parent job running. This would let a \"build-image\" job host a registry that will be alive until all child job are finished.\n\nThis would be a handy generic alternative.",
      "revId": "676f09796afbb1cc5949978427af038352935943",
      "serverId": "4a232e18-c5a9-48ee-94c0-e04e7cca6543",
      "unresolved": false
    }
  ]
}