{
  "comments": [
    {
      "unresolved": false,
      "key": {
        "uuid": "76ee7df5_c272e050",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 27900
      },
      "writtenOn": "2024-06-21T07:05:30Z",
      "side": 1,
      "message": "oh, that\u0027s a great idea to solve this finally by Zuul itself\n\nFor now I ended up deploying HashiVault near the Zuul and built a base jobs that gets a Vault session token for the trusted jobs and hands it over to the job so that the job is then able to go to vault and fetch allowed secrets. The session token is then revoked again by the base job",
      "revId": "0eaff41a012f0b9c232f0f22593b69c994275a40",
      "serverId": "4a232e18-c5a9-48ee-94c0-e04e7cca6543"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "6e994760_f4667260",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 29671
      },
      "writtenOn": "2024-07-16T11:39:09Z",
      "side": 1,
      "message": "Nice! We we\u0027re discussing something like this as well for authentication to trace which jobs were using certain artifacts (instead of allowing anonymous reads).\n\nI understand that this is supposed to generate a JWT for jobs in post-review, but I wonder if it could also generate tokens in pre-review except with a smaller scope (like read only, or only allow uploads to temporary paths). Maybe that could work with a claim for `zuul.post-review`.",
      "revId": "0eaff41a012f0b9c232f0f22593b69c994275a40",
      "serverId": "4a232e18-c5a9-48ee-94c0-e04e7cca6543"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "8c45b9d7_ec22f5ba",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1
      },
      "writtenOn": "2024-07-17T00:12:41Z",
      "side": 1,
      "message": "I like that idea.\n\nFirst a clarification: this spec leverages the \"secret\" framework in Zuul, which means that the tokens aren\u0027t restricted to jobs that run in post-review, but rather they will be provided to playbooks which request access to those secrets.  This normally does mean playbooks that are defined in a trusted project, but those can be on jobs that are parent jobs of untrusted jobs (think how log uploads use a secret but run on untrusted jobs).  Now, if an untrusted playbook requests a secret, that flips some bits in zuul and turns off speculative execution and restricts the job to post-review pipelines.  That may be what you were referring to, but I just wanted to be clear because it\u0027s important for what follows.\n\nSince you want to use one of these tokens in an untrusted playbook, and presumably you also want to retain the ability to have speculative execution in untrusted playbooks, then that presents some incompatibilities with this spec and the current state of Zuul.  We could consider relaxing the restriction around using secrets in untrusted playbooks specifically for this kind of secret, but then that makes the whole system harder to understand (for users and zuul maintainers) because most secrets behave one way except this kind of secret that behaves another way.\n\nBut I can see two ways of doing what you want without opening that can of worms:\n\n1) With the spec as currently written, you could have a base-job pre-run playbook in a trusted repo (probably your \"base\" job) request a secret for this purpose and write it to disk as an Ansible cached fact.  Then subsequent playbooks which needed to download artifacts could use this cached token to access them.\n\nor\n\n2) We could automatically create a token as an \"implied\" secret that meets this criteria and supply it to every playbook.  This would be sort of like how the project ssh key shows up for post-review playbooks.  Since this one would show up everywhere automatically, we don\u0027t have to deal with attaching different kinds of secrets to jobs.\n\nI have an ever-so-slight preference for option #1 because it\u0027s fewer moving parts and I like being able to build functionality from simple primitives.  But if we think that it\u0027s too onerous I think #2 would be fine.",
      "parentUuid": "6e994760_f4667260",
      "revId": "0eaff41a012f0b9c232f0f22593b69c994275a40",
      "serverId": "4a232e18-c5a9-48ee-94c0-e04e7cca6543"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "687c5be2_084a949e",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 29671
      },
      "writtenOn": "2024-07-17T08:15:21Z",
      "side": 1,
      "message": "\u003e 1) With the spec as currently written, you could have a base-job pre-run playbook in a trusted repo (probably your \"base\" job) request a secret for this purpose and write it to disk as an Ansible cached fact. Then subsequent playbooks which needed to download artifacts could use this cached token to access them.\n\nYep that makes sense.",
      "parentUuid": "8c45b9d7_ec22f5ba",
      "revId": "0eaff41a012f0b9c232f0f22593b69c994275a40",
      "serverId": "4a232e18-c5a9-48ee-94c0-e04e7cca6543"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "57c6a767_b766f42d",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 16068
      },
      "writtenOn": "2024-07-18T19:20:13Z",
      "side": 1,
      "message": "I think option 2 is interesting. However I think this might come the risk to be insecure by default. The reason is that the admin of the target system must not forget to not just match for job/pipeline whatever but also for the post-review claim in case speculative use of the secret should be prohibited (which should be the default and is also how secrets in zuul work). However I also can think of various use cases where this would be really useful.\n\nIf we do this I\u0027d suggest that we don\u0027t include a secret fqdn claim into the token and mark usage of this as potentially dangerous when not matching against the post-review claim. Use cases which demand a higher level of security could then still define their own secret and match the claims against the secret fqdn.\n\nI think I\u0027m leaning slightly towards option 1 for the start. Adding option 2 later should be quite easy if option 1 is becoming too cumbersome doesn\u0027t support all use cases.",
      "parentUuid": "687c5be2_084a949e",
      "revId": "0eaff41a012f0b9c232f0f22593b69c994275a40",
      "serverId": "4a232e18-c5a9-48ee-94c0-e04e7cca6543"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "ec6b739f_adfa26e6",
        "filename": "doc/source/developer/specs/zuul-workload-identity-federation.rst",
        "patchSetId": 1
      },
      "lineNbr": 89,
      "author": {
        "id": 1
      },
      "writtenOn": "2024-06-27T14:27:55Z",
      "side": 1,
      "message": "(note) I believe that much like drivers with webhooks, this will be a global url regardless of whether zuul is deployed in whitelabel mode.",
      "revId": "0eaff41a012f0b9c232f0f22593b69c994275a40",
      "serverId": "4a232e18-c5a9-48ee-94c0-e04e7cca6543"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "6f534837_5039edf5",
        "filename": "doc/source/developer/specs/zuul-workload-identity-federation.rst",
        "patchSetId": 1
      },
      "lineNbr": 89,
      "author": {
        "id": 16068
      },
      "writtenOn": "2024-06-27T16:22:53Z",
      "side": 1,
      "message": "I agree",
      "parentUuid": "ec6b739f_adfa26e6",
      "revId": "0eaff41a012f0b9c232f0f22593b69c994275a40",
      "serverId": "4a232e18-c5a9-48ee-94c0-e04e7cca6543"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "7407ad74_eb7cc230",
        "filename": "doc/source/developer/specs/zuul-workload-identity-federation.rst",
        "patchSetId": 1
      },
      "lineNbr": 89,
      "author": {
        "id": 16068
      },
      "writtenOn": "2024-07-18T19:20:13Z",
      "side": 1,
      "message": "I made this more clear in the zuul-web section.",
      "parentUuid": "6f534837_5039edf5",
      "revId": "0eaff41a012f0b9c232f0f22593b69c994275a40",
      "serverId": "4a232e18-c5a9-48ee-94c0-e04e7cca6543"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "52f865bd_a7c2f465",
        "filename": "doc/source/developer/specs/zuul-workload-identity-federation.rst",
        "patchSetId": 1
      },
      "lineNbr": 112,
      "author": {
        "id": 1
      },
      "writtenOn": "2024-06-27T14:27:55Z",
      "side": 1,
      "message": "(note) This will be a small set of keys for the system as a whole (not per-project); we will have multiples if/when they are rotated.",
      "revId": "0eaff41a012f0b9c232f0f22593b69c994275a40",
      "serverId": "4a232e18-c5a9-48ee-94c0-e04e7cca6543"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "cae9edfd_dc742f02",
        "filename": "doc/source/developer/specs/zuul-workload-identity-federation.rst",
        "patchSetId": 1
      },
      "lineNbr": 112,
      "author": {
        "id": 16068
      },
      "writtenOn": "2024-07-18T19:20:13Z",
      "side": 1,
      "message": "Made this more clear.",
      "parentUuid": "52f865bd_a7c2f465",
      "revId": "0eaff41a012f0b9c232f0f22593b69c994275a40",
      "serverId": "4a232e18-c5a9-48ee-94c0-e04e7cca6543"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "f64346e1_0fb03b97",
        "filename": "doc/source/developer/specs/zuul-workload-identity-federation.rst",
        "patchSetId": 1
      },
      "lineNbr": 140,
      "author": {
        "id": 1
      },
      "writtenOn": "2024-06-27T14:27:55Z",
      "side": 1,
      "message": "We currently prepare the secrets before running any playbooks (ie, we prepare all the secrets, then run all the playbooks).  Are you suggesting that for this we prepare each oidc secret before each playbook?  That would make sense because it would reduce the time delta between generation and first use.  If that\u0027s what you mean, let\u0027s change this to read:\n\n  The ID token will be generated in the executor immediately before running a playbook which requires it.\n\nIt\u0027s also the case that one secret may be used by more than one playbook.  Each of pre-run, run, and post-run (and also cleanup) can take a list of playbooks, and a job can have all of those.  So an open question for me is:\n\n  Do we use the same ID token for a given secret across all playbooks that have access to it?  Or do we generate a new ID token for each playbook?\n\nThe expiration time seems to be the main concern here.  It may need to be quite large to be used both in pre-run and post-run playbooks of a large job.",
      "revId": "0eaff41a012f0b9c232f0f22593b69c994275a40",
      "serverId": "4a232e18-c5a9-48ee-94c0-e04e7cca6543"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "d4995573_68a464de",
        "filename": "doc/source/developer/specs/zuul-workload-identity-federation.rst",
        "patchSetId": 1
      },
      "lineNbr": 140,
      "author": {
        "id": 16068
      },
      "writtenOn": "2024-06-27T16:22:53Z",
      "side": 1,
      "message": "Yes, generating the ID token immediately before running a playbook was my intention here. I will update this. Regarding multiple playbooks using the same secret I think it makes sense to re-generate the ID token due to the TTL. So I\u0027ll make this clear as well/",
      "parentUuid": "f64346e1_0fb03b97",
      "revId": "0eaff41a012f0b9c232f0f22593b69c994275a40",
      "serverId": "4a232e18-c5a9-48ee-94c0-e04e7cca6543"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "0ec14467_6e3d5dbc",
        "filename": "doc/source/developer/specs/zuul-workload-identity-federation.rst",
        "patchSetId": 1
      },
      "lineNbr": 161,
      "author": {
        "id": 27900
      },
      "writtenOn": "2024-06-21T11:42:40Z",
      "side": 1,
      "message": "typo: determine",
      "revId": "0eaff41a012f0b9c232f0f22593b69c994275a40",
      "serverId": "4a232e18-c5a9-48ee-94c0-e04e7cca6543"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "0bd40794_3fdfead2",
        "filename": "doc/source/developer/specs/zuul-workload-identity-federation.rst",
        "patchSetId": 1
      },
      "lineNbr": 166,
      "author": {
        "id": 1
      },
      "writtenOn": "2024-06-27T14:27:55Z",
      "side": 1,
      "message": "The job-name will change if inherited from (unless you mean the job-name of the job that uses the secret, not the final job that it inherits from).  That seems useful to me, in that if someone sets up a base job that uses a secret and someone inherits from it, there is some indication to the IDC which job is actually using it.  But this would be dangerous to rely on instead of sub, so we should probably put a big warning sign in the docs about this.",
      "revId": "0eaff41a012f0b9c232f0f22593b69c994275a40",
      "serverId": "4a232e18-c5a9-48ee-94c0-e04e7cca6543"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "c8fa9e06_cbaa6e76",
        "filename": "doc/source/developer/specs/zuul-workload-identity-federation.rst",
        "patchSetId": 1
      },
      "lineNbr": 166,
      "author": {
        "id": 16068
      },
      "writtenOn": "2024-06-27T16:22:53Z",
      "side": 1,
      "message": "I think we still can discuss wether we\u0027ll need this at all as standard claims. In most cases I think the matching will be against the sub which is probably the only identifier which is really protected by zuul\u0027s secret mechanism. If we decide to put that information there by default (for informational, maybe logging purposes on the target service) I agree that we should put a warning in the docs.",
      "parentUuid": "0bd40794_3fdfead2",
      "revId": "0eaff41a012f0b9c232f0f22593b69c994275a40",
      "serverId": "4a232e18-c5a9-48ee-94c0-e04e7cca6543"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "577bcabe_b457e0cd",
        "filename": "doc/source/developer/specs/zuul-workload-identity-federation.rst",
        "patchSetId": 1
      },
      "lineNbr": 166,
      "author": {
        "id": 29671
      },
      "writtenOn": "2024-07-17T08:15:21Z",
      "side": 1,
      "message": "\u003e In most cases I think the matching will be against the sub which is probably the only identifier which is really protected by zuul\u0027s secret mechanism.\n\nAs discussed below, if we were to generate tokens from a trusted context in pre-review I believe we would mostly match against a post-review and project claim rather than subject.\n\nIf the default claims are limited to subject (secret fqdn/id), job name and playbook we may want to allow templating in the additional claims configured in the oidc secret to make it possible to add information about the context the token was generated for. Instead I\u0027m leaning towards adding more zuul data as default claims since it seems easier to build standardized tooling around that.\n\nIs there a drawback to adding too many claims?",
      "parentUuid": "c8fa9e06_cbaa6e76",
      "revId": "0eaff41a012f0b9c232f0f22593b69c994275a40",
      "serverId": "4a232e18-c5a9-48ee-94c0-e04e7cca6543"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "9e2178cd_dedfd841",
        "filename": "doc/source/developer/specs/zuul-workload-identity-federation.rst",
        "patchSetId": 1
      },
      "lineNbr": 166,
      "author": {
        "id": 1
      },
      "writtenOn": "2024-07-17T13:30:05Z",
      "side": 1,
      "message": "I think for the use case you describe (which is mostly logging), you\u0027d want to include the build uuid.  I definitely think we can/should include that here.\n\nhttps://stackoverflow.com/questions/26033983/what-is-the-maximum-size-of-jwt-token\n\nI think we can put a few standard claims in there, but we may want to avoid adding too many.  As for generalized templating, that opens a potential issue with whether they can be trusted, since it isn\u0027t necessarily zuul making the claims at that point, but the user who created the secret.  So we probably want to avoid that unless we have a really good reason.",
      "parentUuid": "577bcabe_b457e0cd",
      "revId": "0eaff41a012f0b9c232f0f22593b69c994275a40",
      "serverId": "4a232e18-c5a9-48ee-94c0-e04e7cca6543"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "7c92f41a_3ed5372b",
        "filename": "doc/source/developer/specs/zuul-workload-identity-federation.rst",
        "patchSetId": 1
      },
      "lineNbr": 166,
      "author": {
        "id": 16068
      },
      "writtenOn": "2024-07-18T19:20:13Z",
      "side": 1,
      "message": "I added build-uuid, pipeline and tenant as well.",
      "parentUuid": "9e2178cd_dedfd841",
      "revId": "0eaff41a012f0b9c232f0f22593b69c994275a40",
      "serverId": "4a232e18-c5a9-48ee-94c0-e04e7cca6543"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "df5519f4_4d9a68ec",
        "filename": "doc/source/developer/specs/zuul-workload-identity-federation.rst",
        "patchSetId": 1
      },
      "lineNbr": 191,
      "author": {
        "id": 1
      },
      "writtenOn": "2024-06-27T14:27:55Z",
      "side": 1,
      "message": "Our keystorage schema currently has a schema for handling rotation of keys by using the following data structure at the key location:\n{ \u0027schema\u0027: 1,\n  \u0027keys\u0027: [\n    {\u0027version\u0027: 0,\n     \u0027created\u0027: timestamp,\n     \u0027private_key\u0027: blob},\n    ...\n  ]}\n\nWe might use the same for this.  Then just store that data structure at `/keystorage/oidc`.  That would increase parity with the other key systems.",
      "revId": "0eaff41a012f0b9c232f0f22593b69c994275a40",
      "serverId": "4a232e18-c5a9-48ee-94c0-e04e7cca6543"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "d8286ca2_daca0c29",
        "filename": "doc/source/developer/specs/zuul-workload-identity-federation.rst",
        "patchSetId": 1
      },
      "lineNbr": 191,
      "author": {
        "id": 16068
      },
      "writtenOn": "2024-06-27T16:22:53Z",
      "side": 1,
      "message": "Good idea",
      "parentUuid": "df5519f4_4d9a68ec",
      "revId": "0eaff41a012f0b9c232f0f22593b69c994275a40",
      "serverId": "4a232e18-c5a9-48ee-94c0-e04e7cca6543"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "3d219f70_4ea59a7c",
        "filename": "doc/source/developer/specs/zuul-workload-identity-federation.rst",
        "patchSetId": 1
      },
      "lineNbr": 204,
      "author": {
        "id": 1
      },
      "writtenOn": "2024-06-27T14:27:55Z",
      "side": 1,
      "message": "Probably easier to just have the web server regenerate the public keys on startup or whenever the keystore is updated.  Will only take a second, and we don\u0027t have to deal with extra data storage/sync.",
      "revId": "0eaff41a012f0b9c232f0f22593b69c994275a40",
      "serverId": "4a232e18-c5a9-48ee-94c0-e04e7cca6543"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "6d2d34e7_686287f1",
        "filename": "doc/source/developer/specs/zuul-workload-identity-federation.rst",
        "patchSetId": 1
      },
      "lineNbr": 204,
      "author": {
        "id": 16068
      },
      "writtenOn": "2024-06-27T16:22:53Z",
      "side": 1,
      "message": "Sounds good as well, my main thought about this was to cache the rendered response so we don\u0027t have to call into cryptography on every request.",
      "parentUuid": "3d219f70_4ea59a7c",
      "revId": "0eaff41a012f0b9c232f0f22593b69c994275a40",
      "serverId": "4a232e18-c5a9-48ee-94c0-e04e7cca6543"
    }
  ]
}