{
  "comments": [
    {
      "unresolved": true,
      "key": {
        "uuid": "be4bfd9d_27d5d680",
        "filename": "doc/source/job-content.rst",
        "patchSetId": 10
      },
      "lineNbr": 1050,
      "author": {
        "id": 4146
      },
      "writtenOn": "2025-01-07T18:17:19Z",
      "side": 1,
      "message": "Maybe note that the value will be None if no determination could be made?\n\nAlso, it is possible for a job to autohold when autohold_if_failure is False. The reason for this is we prepare the job vars before the job starts but we evaluate autoholds when the job completes. This means there is a period of time where a job can start and set autohold_if_failure to False then an autohold is added, then the job fails and is held. I don\u0027t think there is a good solution to this maybe the best thing is simply to document that possibility here?",
      "revId": "564289b5be0349d6ff76d7edb3c6da17288536ce",
      "serverId": "4a232e18-c5a9-48ee-94c0-e04e7cca6543"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "73427406_7722bb75",
        "filename": "doc/source/job-content.rst",
        "patchSetId": 10
      },
      "lineNbr": 1050,
      "author": {
        "id": 1
      },
      "writtenOn": "2025-01-07T18:41:17Z",
      "side": 1,
      "message": "Matthieu mentioned that they currently use the API to achieve this result.  Doing that is more reliable than this variable for the reason you mention.\n\nIn addition to the example Clark cited, there\u0027s also meeting the autohold max.  We might start 10 jobs that fail and hold 1.\n\nAlso, it\u0027s very much expected that we may autohold on non-failure states in the future; adding this variable now with this name makes future changes ambiguous if we autohold on success.\n\nThis idea is problematic, and I\u0027m not enthusiastic about it.  I would prefer you explore other approaches.",
      "parentUuid": "be4bfd9d_27d5d680",
      "revId": "564289b5be0349d6ff76d7edb3c6da17288536ce",
      "serverId": "4a232e18-c5a9-48ee-94c0-e04e7cca6543"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "d030f9de_5f527b8a",
        "filename": "doc/source/job-content.rst",
        "patchSetId": 10
      },
      "lineNbr": 1050,
      "author": {
        "id": 7186
      },
      "writtenOn": "2025-01-08T15:17:26Z",
      "side": 1,
      "message": "Okay, I see now how that variable would end up being inaccurate in many cases. It\u0027s worth noting that it means that depending on when the call to the REST API is made, the REST API result is also susceptible to this issue.\n\nHow about providing instead a \"autohold_id_matches\" variable that would be a list of autoholds (their ids) that *could potentially* trigger for the current build?\n\nThis would spare our users a call to the REST API with a reasonable trade-off. The users are expected to be disciplined enough that it can be assumed from \"autohold_id_matches\" not being empty, that the job will hold eventually if the right conditions are fulfilled (failure for now, systematically eventually in the future). With a precise enough ref filter, a large enough autohold max value, and control over what jobs are being run concurrently, this can be achieved.\n\nWould that work for you?",
      "parentUuid": "73427406_7722bb75",
      "revId": "564289b5be0349d6ff76d7edb3c6da17288536ce",
      "serverId": "4a232e18-c5a9-48ee-94c0-e04e7cca6543"
    }
  ]
}