{
  "comments": [
    {
      "unresolved": false,
      "key": {
        "uuid": "95e70e03_5d6e9442",
        "filename": "/COMMIT_MSG",
        "patchSetId": 2
      },
      "lineNbr": 14,
      "author": {
        "id": 1
      },
      "writtenOn": "2023-04-13T21:49:50Z",
      "side": 1,
      "message": "This seems like a reasonable change, but can you elaborate on the assumption you describe?\n\nI\u0027ve had my head in the pipeline processor for a while now, and I was not operating under that assumption, so I\u0027d like to correct my understanding.  Also, I\u0027d like to know more about how it broke -- do you have any details about why it looped indefinitely?",
      "revId": "3edbc1f1be71f65632432a806f9fc5efee10c584",
      "serverId": "4a232e18-c5a9-48ee-94c0-e04e7cca6543"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "3abaab4c_ec800746",
        "filename": "/COMMIT_MSG",
        "patchSetId": 2
      },
      "lineNbr": 14,
      "author": {
        "id": 27582
      },
      "writtenOn": "2023-04-14T08:27:05Z",
      "side": 1,
      "message": "I think this assumption is implicit in some places - e.g. [0] - but it\u0027s also mentioned in [1].\n\nAllowing non-cycle item in-between items of the same bundle would also lead to a different set of changes being used for the items in the bundle depending on the position in the queue. \n\nFor example given a circular dependency `A\u003c-\u003eB` and a non-cycle dependency `A-\u003eC` we could end up with a queue state of `[A, C, B(head)]`.\n\nWith that, builds for `B` would include change `A+B`, but builds for `A` would have `A,B,C`.\n\nThis could also have consequences in combination with job de-duplication. I think we are not checking if the same set of changes is used when deciding whether to dedup or not.\n\nThe problem we\u0027ve seen was related to the condition in [0] where all items in the bundle were finished and one of the bundle items was at the head of the queue. Another item that was not part of the bundle was enqueued in-between cycle items and wasn\u0027t ready to report yet, leading to the pipeline processor always reporting an item as changed and with that leading to the infinite loop.\n\n[0] https://opendev.org/zuul/zuul/src/branch/master/zuul/manager/__init__.py#L1651-L1656\n[1] https://opendev.org/zuul/zuul/src/branch/master/zuul/manager/__init__.py#L646-L649",
      "parentUuid": "95e70e03_5d6e9442",
      "revId": "3edbc1f1be71f65632432a806f9fc5efee10c584",
      "serverId": "4a232e18-c5a9-48ee-94c0-e04e7cca6543"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "6a8d62c1_4790ec82",
        "filename": "zuul/manager/__init__.py",
        "patchSetId": 2
      },
      "lineNbr": 710,
      "author": {
        "id": 4146
      },
      "writtenOn": "2023-05-22T23:17:44Z",
      "side": 1,
      "message": "Do we need to remove any items from this set that are part of the cycle? Something like:\n\n```\n        return set(\n            itertools.chain.from_iterable(\n                dependency_graph[c] for c in cycle if c !\u003d change)\n        ) - set(cycle)\n```\n\nIn particular I\u0027m worried that elements of the cycle can be needed by other elements of the cycle and if we try to insert them ahead in the queue we may end up in a recursive loop that never ends?\n\nThe test almost covers this case I think so maybe this is a non issue due to some smart code elsewhere? However we only approve A and let everything else process from there. Which means we\u0027ll only call this function on A I think and then we skip A which has the depends on C outside the cycle due to `if c !\u003d change`.\n\nIf this isn\u0027t necessary for some reason maybe we need to make note of that here? Would probably also be a good idea to make a slightly more complicated test that ensures that ever cycle member has an external dependency too. So A \u003c-\u003e B and A -\u003e C and B -\u003e D? I think that would cover it.",
      "revId": "3edbc1f1be71f65632432a806f9fc5efee10c584",
      "serverId": "4a232e18-c5a9-48ee-94c0-e04e7cca6543"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "ef125592_39e667d9",
        "filename": "zuul/manager/__init__.py",
        "patchSetId": 2
      },
      "lineNbr": 710,
      "author": {
        "id": 27582
      },
      "writtenOn": "2023-05-23T06:56:51Z",
      "side": 1,
      "message": "I don\u0027t think this is an issue as we prevent such kind of scenarios by checking if a change is already part of the history during enqueue.\n\nHowever, I think we could subtract the cycle changes here as those are already considered separately.",
      "parentUuid": "6a8d62c1_4790ec82",
      "revId": "3edbc1f1be71f65632432a806f9fc5efee10c584",
      "serverId": "4a232e18-c5a9-48ee-94c0-e04e7cca6543"
    }
  ]
}