{
  "comments": [
    {
      "key": {
        "uuid": "3f044301_1eca626c",
        "filename": "zuul/driver/github/githubsource.py",
        "patchSetId": 10
      },
      "lineNbr": 51,
      "author": {
        "id": 1
      },
      "writtenOn": "2017-05-05T20:41:27Z",
      "side": 1,
      "message": "We should check how often this gets called -- I think it may get called _a lot_ (like, every pass through the NNFI algorithm).  In that case, we should really hit that API call when we query the PR initially and store the result.  If we get an event that would cause that to change, then we can just update the value on the existing change singleton (this is why connections cache changes, so they can do out-of-band updates).\n\nThen this method would just operate on the data on the change object.",
      "revId": "3303c4df4da0a199cb90717eabc084716a5ff0fd",
      "serverId": "4a232e18-c5a9-48ee-94c0-e04e7cca6543",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "3f044301_4057dc03",
        "filename": "zuul/driver/github/githubsource.py",
        "patchSetId": 10
      },
      "lineNbr": 51,
      "author": {
        "id": 6589
      },
      "writtenOn": "2017-05-07T18:06:25Z",
      "side": 1,
      "message": "In a commit later than that, we introduce a caching layer, as Github supports etags, which can tell us if the cached response we have is still valid. It\u0027ll be a quick API call and it will not count against API rate limits. \n\nWe could cache it completely internally, however since the value could change out from under Zuul\u0027s nose, it might be better to use Github\u0027s own caching mechanism.\n\nI thought I had removed this TODO and added the API call, but looks like I didn\u0027t do that. I\u0027ll add one in here.",
      "parentUuid": "3f044301_1eca626c",
      "revId": "3303c4df4da0a199cb90717eabc084716a5ff0fd",
      "serverId": "4a232e18-c5a9-48ee-94c0-e04e7cca6543",
      "unresolved": false
    }
  ]
}