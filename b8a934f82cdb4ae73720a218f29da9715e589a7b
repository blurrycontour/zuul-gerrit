{
  "comments": [
    {
      "unresolved": true,
      "key": {
        "uuid": "3a32dc32_fc92b9d9",
        "filename": "zuul/driver/gerrit/gerritconnection.py",
        "patchSetId": 1
      },
      "lineNbr": 206,
      "author": {
        "id": 27582
      },
      "writtenOn": "2025-02-14T14:03:49Z",
      "side": 1,
      "message": "Isn\u0027t the intention also to prevent concurrent modification of the same change object by different threads? Letting `future` here continue despite intersecting/conflicting change networks would allow that IIUC.",
      "revId": "b8a934f82cdb4ae73720a218f29da9715e589a7b",
      "serverId": "4a232e18-c5a9-48ee-94c0-e04e7cca6543"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "ddb2bb8a_d246d318",
        "filename": "zuul/driver/gerrit/gerritconnection.py",
        "patchSetId": 1
      },
      "lineNbr": 206,
      "author": {
        "id": 1
      },
      "writtenOn": "2025-02-14T15:36:32Z",
      "side": 1,
      "message": "I think you\u0027re suggesting that rather than allowing the oldest network to continue, we should allow the first network that encountered the conflicting change to continue.  Therefore, you suggest this method should always let \"f\" win and never let \"future\" win.\n\nThat may be a reasonable strategy too.\n\nI think in practice the current approach is not an issue because we don\u0027t start writing changes to the cache until we reach the first leaf node of the tree, which would tend to mean that the newer network is unlikely to have written any changes.\n\nMoreover, while I think it\u0027s good to avoid duplicate ZK writes, I don\u0027t think it\u0027s strictly necessary; they should end up writing the same data.\n\nBut still, I think we should try your idea -- it may indeed save some ZK writes and possibly keep things simpler.  I\u0027ll make the switch in a followup so we can evaluate it on its own.",
      "parentUuid": "3a32dc32_fc92b9d9",
      "revId": "b8a934f82cdb4ae73720a218f29da9715e589a7b",
      "serverId": "4a232e18-c5a9-48ee-94c0-e04e7cca6543"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "898870e5_715e6508",
        "filename": "zuul/driver/gerrit/gerritconnection.py",
        "patchSetId": 1
      },
      "lineNbr": 206,
      "author": {
        "id": 27582
      },
      "writtenOn": "2025-02-14T16:15:14Z",
      "side": 1,
      "message": "I\u0027m less concerned about ZK writes and rather about having potentially multiple change objects for the same change around. We had a similar issue with the Github driver in the beginning until we added locking around the change update.",
      "parentUuid": "ddb2bb8a_d246d318",
      "revId": "b8a934f82cdb4ae73720a218f29da9715e589a7b",
      "serverId": "4a232e18-c5a9-48ee-94c0-e04e7cca6543"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "6bbd28a7_0165d79d",
        "filename": "zuul/driver/gerrit/gerritconnection.py",
        "patchSetId": 1
      },
      "lineNbr": 206,
      "author": {
        "id": 27582
      },
      "writtenOn": "2025-02-14T16:31:58Z",
      "side": 1,
      "message": "Ok, we are settling on a single change object when we call `change_cache.updateChangeWithRetry()`.",
      "parentUuid": "898870e5_715e6508",
      "revId": "b8a934f82cdb4ae73720a218f29da9715e589a7b",
      "serverId": "4a232e18-c5a9-48ee-94c0-e04e7cca6543"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "60dd9578_bc158c97",
        "filename": "zuul/driver/gerrit/gerritconnection.py",
        "patchSetId": 1
      },
      "lineNbr": 451,
      "author": {
        "id": 27582
      },
      "writtenOn": "2025-02-14T14:03:49Z",
      "side": 1,
      "message": "I think with that we might also do less queries than before, e.g. when there are multiple events for the same change arriving in quick succession. It looks like so far we\u0027ve always refreshed the change unconditionally (unless I missed something).",
      "revId": "b8a934f82cdb4ae73720a218f29da9715e589a7b",
      "serverId": "4a232e18-c5a9-48ee-94c0-e04e7cca6543"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "30821cb0_866646a3",
        "filename": "zuul/driver/gerrit/gerritconnection.py",
        "patchSetId": 1
      },
      "lineNbr": 451,
      "author": {
        "id": 1
      },
      "writtenOn": "2025-02-14T15:36:32Z",
      "side": 1,
      "message": "The single-threaded algorithm would not have refreshed the change in that case because:\n\n1) we handle events one at a time\n2) we delay at least 10 seconds after the real event time before we do any processing\n3) just above this in lines 434-436, we check if the change was updated after our connection event time\n\nThat means the first event (at t\u003d0) will delay 10 seconds, update the change (at t\u003d10), and write the current ltime on the change.\n\nThe second event (assuming it arrives within 10 seconds, let\u0027s say 1 second, t\u003d1) will delay 0 additional seconds, see that the change\u0027s ltime is after it\u0027s event ltime, and will skip this block.\n\nThis new change where we push the connection ltime down to other methods is necessary because we no longer guarantee #1 in the list above, so we have to check whether the change is updated in the cache more often during the rest of the process.",
      "parentUuid": "60dd9578_bc158c97",
      "revId": "b8a934f82cdb4ae73720a218f29da9715e589a7b",
      "serverId": "4a232e18-c5a9-48ee-94c0-e04e7cca6543"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "e5d73bcc_c9b219b0",
        "filename": "zuul/driver/gerrit/gerritconnection.py",
        "patchSetId": 1
      },
      "lineNbr": 451,
      "author": {
        "id": 27582
      },
      "writtenOn": "2025-02-14T16:15:14Z",
      "side": 1,
      "message": "Makes sense. I missed that check above.",
      "parentUuid": "30821cb0_866646a3",
      "revId": "b8a934f82cdb4ae73720a218f29da9715e589a7b",
      "serverId": "4a232e18-c5a9-48ee-94c0-e04e7cca6543"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "9007b47c_9fd973df",
        "filename": "zuul/driver/gerrit/gerritconnection.py",
        "patchSetId": 1
      },
      "lineNbr": 754,
      "author": {
        "id": 27582
      },
      "writtenOn": "2025-02-14T14:03:49Z",
      "side": 1,
      "message": "Do we need to reset the network future here? Just wondering if it might already have some query results that could be reused by other futures so it could make sense to keep the instance around.\n\nPart of the cached query data could be unique to this particular change network, so queries could potentially be executed multiple times.\n\n\nE.g given the following two networks:\n- A -\u003e B -\u003e X -\u003e ...\n- C -\u003e D -\u003e X -\u003e ...\n\nIt looks like we\u0027d throw away cached query data for C and D when a conflict for X on that network is detected and need to re-query those changes.",
      "range": {
        "startLine": 753,
        "startChar": 20,
        "endLine": 754,
        "endChar": 41
      },
      "revId": "b8a934f82cdb4ae73720a218f29da9715e589a7b",
      "serverId": "4a232e18-c5a9-48ee-94c0-e04e7cca6543"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "2b1a3814_2f5531ac",
        "filename": "zuul/driver/gerrit/gerritconnection.py",
        "patchSetId": 1
      },
      "lineNbr": 754,
      "author": {
        "id": 1
      },
      "writtenOn": "2025-02-14T15:36:32Z",
      "side": 1,
      "message": "When the collision is detected, the manager will merge the query cache of the loser into the winner (see mergeQueryResults), so we no longer need to keep the network around.\n\nAssuming the networks are stable throughout the process (we can\u0027t guarantee that, things can change in gerrit, but we also can\u0027t really do anything about that since we can\u0027t lock gerrit during the process), then the winning network should keep accumulating all of the losers.\n\nBut I think you may have meant specifically for this thread -- as in, should we keep the network around for this thread so it doesn\u0027t need to repeat any queries.\n\nIn practice, once the network loses, it should wait until the winner finishes, and then it should have nothing left to do.  Its first call to _updateChange should immediately detect that the change cache is up to date, and it will exit the whole process.\n\nNow, if the min_ltime of the winning network is not sufficient for this thread\u0027s event, then it may need to perform queries again.\n\nPerhaps that\u0027s a good reason to do as you suggest (or at least copy over the query cache).  If we do that, we should probably do something where all the networks share the same query cache object.  Then any threads that decide they still need to do work would all have the latest version of every query already performed.\n\nLet\u0027s look into this as a followup too.",
      "parentUuid": "9007b47c_9fd973df",
      "revId": "b8a934f82cdb4ae73720a218f29da9715e589a7b",
      "serverId": "4a232e18-c5a9-48ee-94c0-e04e7cca6543"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "22d90007_77ef34af",
        "filename": "zuul/driver/gerrit/gerritconnection.py",
        "patchSetId": 1
      },
      "lineNbr": 754,
      "author": {
        "id": 27582
      },
      "writtenOn": "2025-02-14T16:15:14Z",
      "side": 1,
      "message": "I think for my example we\u0027d still need to update/query changes C, D once more as they don\u0027t show up in the change network of A even if that already happened before we detected a conflict.",
      "parentUuid": "2b1a3814_2f5531ac",
      "revId": "b8a934f82cdb4ae73720a218f29da9715e589a7b",
      "serverId": "4a232e18-c5a9-48ee-94c0-e04e7cca6543"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "57827ed2_9a0b233e",
        "filename": "zuul/driver/gerrit/gerritconnection.py",
        "patchSetId": 1
      },
      "lineNbr": 754,
      "author": {
        "id": 1
      },
      "writtenOn": "2025-02-14T16:24:00Z",
      "side": 1,
      "message": "I understand your example as this:\n\nThread 1 queries A, B, X.\nThread 2 queries C, D, X.\n\nThese happen almost simultaneously, so thread 2 asks for permission to query X just after thread 1 was granted permission.  When thread 2 asks for permission for X, it loses.\n\nAt that point, we use mergeQueryResults to copy the query cache from thread/network 2 to thread/network 1.  So thread 1 now has [A, B, X, C, D] in its query cache.\n\nOnce network 1 proceeds past X and starts working on, let\u0027s say D is the next one it queries, then it will find that D is already in its query cache and doesn\u0027t need to query it.",
      "parentUuid": "22d90007_77ef34af",
      "revId": "b8a934f82cdb4ae73720a218f29da9715e589a7b",
      "serverId": "4a232e18-c5a9-48ee-94c0-e04e7cca6543"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "b746b12a_be4f0d9b",
        "filename": "zuul/driver/gerrit/gerritconnection.py",
        "patchSetId": 1
      },
      "lineNbr": 754,
      "author": {
        "id": 27582
      },
      "writtenOn": "2025-02-14T16:31:58Z",
      "side": 1,
      "message": "I think with https://review.opendev.org/c/zuul/zuul/+/941684 that\u0027s indeed the case, but as it is in this change we\u0027d start with an empty change network and with that an empty cache for thread 2 after thread 1 finished. Because thread 2 will unwind up to the start of the network so it needs to start all over with C.\n\nBut maybe I\u0027m also missing something.",
      "parentUuid": "57827ed2_9a0b233e",
      "revId": "b8a934f82cdb4ae73720a218f29da9715e589a7b",
      "serverId": "4a232e18-c5a9-48ee-94c0-e04e7cca6543"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "ee8fe91e_0c1c1fc8",
        "filename": "zuul/driver/gerrit/gerritconnection.py",
        "patchSetId": 1
      },
      "lineNbr": 1469,
      "author": {
        "id": 27582
      },
      "writtenOn": "2025-02-14T14:03:49Z",
      "side": 1,
      "message": "I\u0027m not quite sure I understand how we\u0027d reach here when we already check the `zuul_query_ltime`of the change in line 900.\n\nCan this be the case when we have queried the change, but unwound the query due to a conflicting update? I guess in that case it would be useful to keep the `ChangeNetworkFuture` instance the same as suggested on line 754 so we could make use of cached queries.",
      "revId": "b8a934f82cdb4ae73720a218f29da9715e589a7b",
      "serverId": "4a232e18-c5a9-48ee-94c0-e04e7cca6543"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "c6a1b917_cf9b06f3",
        "filename": "zuul/driver/gerrit/gerritconnection.py",
        "patchSetId": 1
      },
      "lineNbr": 1469,
      "author": {
        "id": 1
      },
      "writtenOn": "2025-02-14T15:36:32Z",
      "side": 1,
      "message": "Because we may be the winning thread in a conflict, and the query cache from the losing thread was merged with our query cache, but the losing thread never wrote the change to zk because it didn\u0027t get all the way to a leaf node of the network.\n\nSo, yes, it does relate to that case, but as mentioned in the other reply, we do merge the caches of the networks, so in the typical case (all events able to be satisfied by the oldest ltime) we will benefit from that cache.",
      "parentUuid": "ee8fe91e_0c1c1fc8",
      "revId": "b8a934f82cdb4ae73720a218f29da9715e589a7b",
      "serverId": "4a232e18-c5a9-48ee-94c0-e04e7cca6543"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "410fed14_50e2b30c",
        "filename": "zuul/driver/gerrit/gerritconnection.py",
        "patchSetId": 1
      },
      "lineNbr": 1469,
      "author": {
        "id": 27582
      },
      "writtenOn": "2025-02-14T16:15:14Z",
      "side": 1,
      "message": "Acknowledged",
      "parentUuid": "c6a1b917_cf9b06f3",
      "revId": "b8a934f82cdb4ae73720a218f29da9715e589a7b",
      "serverId": "4a232e18-c5a9-48ee-94c0-e04e7cca6543"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "7cee28bd_4b0b723b",
        "filename": "zuul/driver/gerrit/gerritconnection.py",
        "patchSetId": 1
      },
      "lineNbr": 1492,
      "author": {
        "id": 27582
      },
      "writtenOn": "2025-02-14T14:03:49Z",
      "side": 1,
      "message": "This line has a bug that\u0027s addressed by https://review.opendev.org/c/zuul/zuul/+/941626",
      "revId": "b8a934f82cdb4ae73720a218f29da9715e589a7b",
      "serverId": "4a232e18-c5a9-48ee-94c0-e04e7cca6543"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "3c8adfda_1916a244",
        "filename": "zuul/driver/gerrit/gerritconnection.py",
        "patchSetId": 1
      },
      "lineNbr": 1492,
      "author": {
        "id": 1
      },
      "writtenOn": "2025-02-14T15:36:32Z",
      "side": 1,
      "message": "Ack.",
      "parentUuid": "7cee28bd_4b0b723b",
      "revId": "b8a934f82cdb4ae73720a218f29da9715e589a7b",
      "serverId": "4a232e18-c5a9-48ee-94c0-e04e7cca6543"
    }
  ]
}